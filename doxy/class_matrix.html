<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>LibForBES: Matrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="dox_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">LibForBES
   &#160;<span id="projectnumber">0.2</span>
   </div>
   <div id="projectbrief">Solver for nonsmooth convex optimization problems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_matrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Matrix Class Reference<div class="ingroups"><a class="el" href="group___matrix-group.html">Matrix</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A generic matrix API.  
 <a href="class_matrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_matrix_8h_source.html">Matrix.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5269c84de25f7f2ac7d05efcffde1046"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a5269c84de25f7f2ac7d05efcffde1046">MatrixType</a> { <br/>
&#160;&#160;<a class="el" href="class_matrix.html#a5269c84de25f7f2ac7d05efcffde1046abb1c1ce85c5f48fecea0ad55d5587c10">MATRIX_DENSE</a>, 
<a class="el" href="class_matrix.html#a5269c84de25f7f2ac7d05efcffde1046aaca75f6fbf0a161cc6662f2becc5ca29">MATRIX_SPARSE</a>, 
<a class="el" href="class_matrix.html#a5269c84de25f7f2ac7d05efcffde1046a8201b6f37bd6e24656d4a7a6778caaab">MATRIX_DIAGONAL</a>, 
<a class="el" href="class_matrix.html#a5269c84de25f7f2ac7d05efcffde1046ae552eea881669aea988964df27df10fe">MATRIX_LOWERTR</a>, 
<br/>
&#160;&#160;<a class="el" href="class_matrix.html#a5269c84de25f7f2ac7d05efcffde1046a1dda72be4635b65b8d689ec7583239a1">MATRIX_SYMMETRIC</a>
<br/>
 }</td></tr>
<tr class="separator:a5269c84de25f7f2ac7d05efcffde1046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1630a647355c737bcf17e416e6a72018"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a1630a647355c737bcf17e416e6a72018">SparseMatrixType</a> { <a class="el" href="class_matrix.html#a1630a647355c737bcf17e416e6a72018aa7a4271dae437af4d58bf01192b3c08b">SPARSE_UNSYMMETRIC</a> = 0, 
<a class="el" href="class_matrix.html#a1630a647355c737bcf17e416e6a72018aaa2bf3834092da433d0cdeebab65509e">SPARSE_SYMMETRIC_L</a> = 1, 
<a class="el" href="class_matrix.html#a1630a647355c737bcf17e416e6a72018a29b0fc39b437bc41f06b4945ceedbfe7">SPARSE_SYMMETRIC_R</a> = -1
 }</td></tr>
<tr class="separator:a1630a647355c737bcf17e416e6a72018"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2dba13c45127354c9f75ef576f49269b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a2dba13c45127354c9f75ef576f49269b">Matrix</a> ()</td></tr>
<tr class="separator:a2dba13c45127354c9f75ef576f49269b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd0fb761caa04694f223f8528ad6e02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#abcd0fb761caa04694f223f8528ad6e02">Matrix</a> (size_t nr, size_t nc)</td></tr>
<tr class="separator:abcd0fb761caa04694f223f8528ad6e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9947a19f68a43473dfceaee8761110"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb9947a19f68a43473dfceaee8761110"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix</b> (std::pair&lt; size_t, size_t &gt; dimensions)</td></tr>
<tr class="separator:aeb9947a19f68a43473dfceaee8761110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5af01ca18c563132a939ab07fed179"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a7d5af01ca18c563132a939ab07fed179">Matrix</a> (size_t nr, size_t nc, <a class="el" href="class_matrix.html#a5269c84de25f7f2ac7d05efcffde1046">MatrixType</a> matrixType)</td></tr>
<tr class="separator:a7d5af01ca18c563132a939ab07fed179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7027cec8e97984a31995367f0ccc48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#ade7027cec8e97984a31995367f0ccc48">Matrix</a> (size_t nr, size_t nc, const double *data)</td></tr>
<tr class="separator:ade7027cec8e97984a31995367f0ccc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86efe4a80e926f4a237861239d641dca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a86efe4a80e926f4a237861239d641dca">Matrix</a> (size_t nr, size_t nc, const double *data, <a class="el" href="class_matrix.html#a5269c84de25f7f2ac7d05efcffde1046">MatrixType</a> matrixType)</td></tr>
<tr class="separator:a86efe4a80e926f4a237861239d641dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806b603175d91477ca28ccf83ef589ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a806b603175d91477ca28ccf83ef589ea">Matrix</a> (const <a class="el" href="class_matrix.html">Matrix</a> &amp;orig)</td></tr>
<tr class="separator:a806b603175d91477ca28ccf83ef589ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1c3627f573d78a2f08623fdfef990f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a9b1c3627f573d78a2f08623fdfef990f">~Matrix</a> ()</td></tr>
<tr class="separator:a9b1c3627f573d78a2f08623fdfef990f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa753de1a2ed37c8eb934e06823fee179"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#aa753de1a2ed37c8eb934e06823fee179">transpose</a> ()</td></tr>
<tr class="separator:aa753de1a2ed37c8eb934e06823fee179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6530fe4f127ba13a7030b5e48e2859"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#ade6530fe4f127ba13a7030b5e48e2859">get</a> (const size_t i, const size_t j) const </td></tr>
<tr class="separator:ade6530fe4f127ba13a7030b5e48e2859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13362789c86b598e86a817ec469fac8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#ad13362789c86b598e86a817ec469fac8">get</a> (const size_t i) const </td></tr>
<tr class="separator:ad13362789c86b598e86a817ec469fac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b21e3beb1071bd78b920c5b53b3e044"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a8b21e3beb1071bd78b920c5b53b3e044">set</a> (size_t i, size_t j, double val)</td></tr>
<tr class="separator:a8b21e3beb1071bd78b920c5b53b3e044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b720197e7a5fe44f83d942604c0ed9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#ae9b720197e7a5fe44f83d942604c0ed9">getNcols</a> () const </td></tr>
<tr class="separator:ae9b720197e7a5fe44f83d942604c0ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1329328637e15c238ff88d8bd002a90"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#ae1329328637e15c238ff88d8bd002a90">getNrows</a> () const </td></tr>
<tr class="separator:ae1329328637e15c238ff88d8bd002a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563d2eea637fa4cec85649bfdb83e649"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a563d2eea637fa4cec85649bfdb83e649">getData</a> ()</td></tr>
<tr class="separator:a563d2eea637fa4cec85649bfdb83e649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4354c8f295ce0d7bc1593c47a6b0e458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html#a5269c84de25f7f2ac7d05efcffde1046">MatrixType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a4354c8f295ce0d7bc1593c47a6b0e458">getType</a> () const </td></tr>
<tr class="separator:a4354c8f295ce0d7bc1593c47a6b0e458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aad4156bde7ca184d008f84650287c8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a9aad4156bde7ca184d008f84650287c8">getTypeString</a> () const </td></tr>
<tr class="separator:a9aad4156bde7ca184d008f84650287c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c9e38b32c51598d4535823c6d596f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a78c9e38b32c51598d4535823c6d596f7">reshape</a> (size_t nrows, size_t ncols)</td></tr>
<tr class="separator:a78c9e38b32c51598d4535823c6d596f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7493d04952515b36ff3f145ae2244ff6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a7493d04952515b36ff3f145ae2244ff6">isSymmetric</a> () const </td></tr>
<tr class="separator:a7493d04952515b36ff3f145ae2244ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863f25e7addbd2a92b48ed25a7223cfb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a863f25e7addbd2a92b48ed25a7223cfb">isColumnVector</a> () const </td></tr>
<tr class="separator:a863f25e7addbd2a92b48ed25a7223cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb04d447ba10e54fdd9ceef3fbf2aac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#aecb04d447ba10e54fdd9ceef3fbf2aac">isRowVector</a> () const </td></tr>
<tr class="separator:aecb04d447ba10e54fdd9ceef3fbf2aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6750126006caf8bcf092eaac0e01fe08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a6750126006caf8bcf092eaac0e01fe08">isEmpty</a> () const </td></tr>
<tr class="separator:a6750126006caf8bcf092eaac0e01fe08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ff18ea6f0710847b5828361a155c12"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a67ff18ea6f0710847b5828361a155c12">length</a> () const </td></tr>
<tr class="separator:a67ff18ea6f0710847b5828361a155c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2037979913d8ff3fda87484c275a129"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#af2037979913d8ff3fda87484c275a129">norm_fro_sq</a> ()</td></tr>
<tr class="separator:af2037979913d8ff3fda87484c275a129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c3fb9c6f0159041a9d3780d0aa7f0c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#aa0c3fb9c6f0159041a9d3780d0aa7f0c">quad</a> (<a class="el" href="class_matrix.html">Matrix</a> &amp;x) const </td></tr>
<tr class="separator:aa0c3fb9c6f0159041a9d3780d0aa7f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335a1a88224406dd9495deb69b40e540"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a335a1a88224406dd9495deb69b40e540">quad</a> (<a class="el" href="class_matrix.html">Matrix</a> &amp;x, <a class="el" href="class_matrix.html">Matrix</a> &amp;q) const </td></tr>
<tr class="separator:a335a1a88224406dd9495deb69b40e540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498f80096c04994899f302fbbe1abe40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a498f80096c04994899f302fbbe1abe40">toggle_diagonal</a> ()</td></tr>
<tr class="separator:a498f80096c04994899f302fbbe1abe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b85bd659def86b7d7c30c89e284d4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a60b85bd659def86b7d7c30c89e284d4f">plusop</a> ()</td></tr>
<tr class="separator:a60b85bd659def86b7d7c30c89e284d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb3bce122bc4f834c1732eb3abdc397"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#aacb3bce122bc4f834c1732eb3abdc397">plusop</a> (<a class="el" href="class_matrix.html">Matrix</a> *mat) const </td></tr>
<tr class="separator:aacb3bce122bc4f834c1732eb3abdc397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60596b6608bb8a51a2d79afcaf092849"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a60596b6608bb8a51a2d79afcaf092849">operator[]</a> (const size_t sub) const </td></tr>
<tr class="separator:a60596b6608bb8a51a2d79afcaf092849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248b41795fe69f2591aa95f4a5dbac79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a248b41795fe69f2591aa95f4a5dbac79">operator+</a> (<a class="el" href="class_matrix.html">Matrix</a> &amp;right) const </td></tr>
<tr class="separator:a248b41795fe69f2591aa95f4a5dbac79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6e772e2faa6080fadd50c9a2d2b130"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a2d6e772e2faa6080fadd50c9a2d2b130">operator-</a> (<a class="el" href="class_matrix.html">Matrix</a> &amp;right) const </td></tr>
<tr class="separator:a2d6e772e2faa6080fadd50c9a2d2b130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13feaec63b337a207e70bd954956d8ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a13feaec63b337a207e70bd954956d8ba">operator+=</a> (<a class="el" href="class_matrix.html">Matrix</a> &amp;right)</td></tr>
<tr class="separator:a13feaec63b337a207e70bd954956d8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ce920a1bbf67675d4e7717f7afed35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a42ce920a1bbf67675d4e7717f7afed35">operator-=</a> (<a class="el" href="class_matrix.html">Matrix</a> &amp;right)</td></tr>
<tr class="separator:a42ce920a1bbf67675d4e7717f7afed35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f117287672b1edcedf1cab6edaea2b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a6f117287672b1edcedf1cab6edaea2b5">operator*</a> (<a class="el" href="class_matrix.html">Matrix</a> &amp;right)</td></tr>
<tr class="separator:a6f117287672b1edcedf1cab6edaea2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127463de2d624abeaf5924c0f2fe798d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a127463de2d624abeaf5924c0f2fe798d">operator=</a> (const <a class="el" href="class_matrix.html">Matrix</a> &amp;right)</td></tr>
<tr class="separator:a127463de2d624abeaf5924c0f2fe798d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6910c400bcff2148875ce8132baf70e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a6910c400bcff2148875ce8132baf70e9">operator==</a> (const <a class="el" href="class_matrix.html">Matrix</a> &amp;right) const </td></tr>
<tr class="separator:a6910c400bcff2148875ce8132baf70e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35c63af2aa542ef4f2a3d9b5150412c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#ad35c63af2aa542ef4f2a3d9b5150412c">submatrixCopy</a> (size_t row_start, size_t row_end, size_t col_start, size_t col_end)</td></tr>
<tr class="separator:ad35c63af2aa542ef4f2a3d9b5150412c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b765e9e9d2c46bc2f6af1674d7080a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a32b765e9e9d2c46bc2f6af1674d7080a">multiplySubmatrix</a> (<a class="el" href="class_matrix.html">Matrix</a> &amp;rhs, const size_t left_row_start, const size_t left_row_end, const size_t left_col_start, const size_t left_col_end, const size_t right_row_start, const size_t right_row_end, const size_t right_col_start, const size_t right_col_end)</td></tr>
<tr class="separator:a32b765e9e9d2c46bc2f6af1674d7080a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a15c97d92d3cda9517cde2d9edbd06fac"><td class="memItemLeft" align="right" valign="top">static cholmod_common *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a15c97d92d3cda9517cde2d9edbd06fac">cholmod_handle</a> ()</td></tr>
<tr class="separator:a15c97d92d3cda9517cde2d9edbd06fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad018d4ba7a14f4b068e892c3477629b6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#ad018d4ba7a14f4b068e892c3477629b6">destroy_handle</a> ()</td></tr>
<tr class="separator:ad018d4ba7a14f4b068e892c3477629b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b473bbaefb449026e64127a17d517f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a78b473bbaefb449026e64127a17d517f">add</a> (<a class="el" href="class_matrix.html">Matrix</a> &amp;C, double alpha, <a class="el" href="class_matrix.html">Matrix</a> &amp;A, double gamma)</td></tr>
<tr class="separator:a78b473bbaefb449026e64127a17d517f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967b3c0361c14f7539de4712226dac76"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a967b3c0361c14f7539de4712226dac76">mult</a> (<a class="el" href="class_matrix.html">Matrix</a> &amp;C, double alpha, <a class="el" href="class_matrix.html">Matrix</a> &amp;A, <a class="el" href="class_matrix.html">Matrix</a> &amp;B, double gamma)</td></tr>
<tr class="separator:a967b3c0361c14f7539de4712226dac76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac00125ba92e490d4f6aeba0b2ffbed96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac00125ba92e490d4f6aeba0b2ffbed96"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixFactory</b></td></tr>
<tr class="separator:ac00125ba92e490d4f6aeba0b2ffbed96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1a918eadb8b5749ad99b6ebb737ced"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf1a918eadb8b5749ad99b6ebb737ced"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>CholeskyFactorization</b></td></tr>
<tr class="separator:abf1a918eadb8b5749ad99b6ebb737ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7743b464bdd846e5fbef67bd10cdcf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc7743b464bdd846e5fbef67bd10cdcf"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>LDLFactorization</b></td></tr>
<tr class="separator:abc7743b464bdd846e5fbef67bd10cdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a221440b7381e5a346514448f3041b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a221440b7381e5a346514448f3041b8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>S_LDLFactorization</b></td></tr>
<tr class="separator:a5a221440b7381e5a346514448f3041b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d94e4b35755819c28bf205258ae0d80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d94e4b35755819c28bf205258ae0d80"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixWriter</b></td></tr>
<tr class="separator:a0d94e4b35755819c28bf205258ae0d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c437f59e2afd60da8a880e8417856f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#ad5c437f59e2afd60da8a880e8417856f">operator*=</a> (<a class="el" href="class_matrix.html">Matrix</a> &amp;obj, double alpha)</td></tr>
<tr class="separator:ad5c437f59e2afd60da8a880e8417856f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d865fbe59bcafacb9a36d4901d769a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37d865fbe59bcafacb9a36d4901d769a"></a>
<a class="el" href="class_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (double alpha, <a class="el" href="class_matrix.html">Matrix</a> &amp;obj)</td></tr>
<tr class="separator:a37d865fbe59bcafacb9a36d4901d769a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f78084a0dd9b26068bf0e2878406ad"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#ae3f78084a0dd9b26068bf0e2878406ad">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_matrix.html">Matrix</a> &amp;obj)</td></tr>
<tr class="separator:ae3f78084a0dd9b26068bf0e2878406ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A generic matrix API. </p>
<dl class="section version"><dt>Version</dt><dd>version 0.3</dd></dl>
<dl class="section date"><dt>Date</dt><dd>Created on July 7, 2015, 8:02 PM</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Operations with dense matrices are supported by BLAS and LAPACK routines, while sparse matrix operations are delegated to SuiteSparse routines.</dd>
<dd>
A factor for this class, namely <a class="el" href="class_matrix_factory.html" title="Use this class to create instances of Matrix. ">MatrixFactory</a>, facilitates the creation of matrices.</dd></dl>
<dl class="section user"><dt></dt><dd>A generic matrix which can be an unstructured dense, a structured dense (e.g., symmetric or lower triangular, stored in packed form) or a dense matrix. This class provides a uniform access framework (an API) to matrix-matrix operations (e.g., addition and multiplication), factorizations and other useful operations.</dd></dl>
<dl class="section user"><dt></dt><dd>To construct a <a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a> you can use one of this class's constructors. However, for sparse matrices it is advisable to use the factory class <code><a class="el" href="class_matrix_factory.html" title="Use this class to create instances of Matrix. ">MatrixFactory</a></code>.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Do not create methods where arguments of type Matrix are passed as const. Most matrix operations modify the object's internal state (especially when working with sparse matrices).</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_matrix_factory.html" title="Use this class to create instances of Matrix. ">MatrixFactory</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="matop_example_8cpp-example.html#_a0">matop_example.cpp</a>, <a class="el" href="matrix_example_8cpp-example.html#_a0">matrix_example.cpp</a>, <a class="el" href="qp_box_8cpp-example.html#_a0">qp_box.cpp</a>, and <a class="el" href="shallow_example_8cpp-example.html#_a0">shallow_example.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a5269c84de25f7f2ac7d05efcffde1046"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_matrix.html#a5269c84de25f7f2ac7d05efcffde1046">Matrix::MatrixType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Types of matrices. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a5269c84de25f7f2ac7d05efcffde1046abb1c1ce85c5f48fecea0ad55d5587c10"></a>MATRIX_DENSE</em>&#160;</td><td class="fielddoc">
<p>A dense matrix </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5269c84de25f7f2ac7d05efcffde1046aaca75f6fbf0a161cc6662f2becc5ca29"></a>MATRIX_SPARSE</em>&#160;</td><td class="fielddoc">
<p>A sparse matrix (powered by SuiteSparse) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5269c84de25f7f2ac7d05efcffde1046a8201b6f37bd6e24656d4a7a6778caaab"></a>MATRIX_DIAGONAL</em>&#160;</td><td class="fielddoc">
<p>A diagonal matrix </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5269c84de25f7f2ac7d05efcffde1046ae552eea881669aea988964df27df10fe"></a>MATRIX_LOWERTR</em>&#160;</td><td class="fielddoc">
<p>A lower-triangular matrix </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5269c84de25f7f2ac7d05efcffde1046a1dda72be4635b65b8d689ec7583239a1"></a>MATRIX_SYMMETRIC</em>&#160;</td><td class="fielddoc">
<p>A symmetric matrix </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a1630a647355c737bcf17e416e6a72018"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_matrix.html#a1630a647355c737bcf17e416e6a72018">Matrix::SparseMatrixType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse type of matrix </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a1630a647355c737bcf17e416e6a72018aa7a4271dae437af4d58bf01192b3c08b"></a>SPARSE_UNSYMMETRIC</em>&#160;</td><td class="fielddoc">
<p>Not symmetric sparse </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a1630a647355c737bcf17e416e6a72018aaa2bf3834092da433d0cdeebab65509e"></a>SPARSE_SYMMETRIC_L</em>&#160;</td><td class="fielddoc">
<p>Symmetric sparse and entries in the lower triangular part are transposed and added to the upper triangular part when the matrix is converted to cholmod_sparse form. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a1630a647355c737bcf17e416e6a72018a29b0fc39b437bc41f06b4945ceedbfe7"></a>SPARSE_SYMMETRIC_R</em>&#160;</td><td class="fielddoc">
<p>Symmetric sparse and entries in the upper triangular part are transposed and added to the lower triangular part when the matrix is converted to cholmod_sparse form. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2dba13c45127354c9f75ef576f49269b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix::Matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor for an empty <code><a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a></code> object. </p>

</div>
</div>
<a class="anchor" id="abcd0fb761caa04694f223f8528ad6e02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix::Matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty dense matrix of given dimensions.</p>
<dl class="section remark"><dt>Remarks</dt><dd>this constructor will allocate memory of <code>nr*nc*sizeof(double)</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>number of rows </td></tr>
    <tr><td class="paramname">nc</td><td>number of columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d5af01ca18c563132a939ab07fed179"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix::Matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix.html#a5269c84de25f7f2ac7d05efcffde1046">MatrixType</a>&#160;</td>
          <td class="paramname"><em>matrixType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a matrix of given dimensions and given type.</p>
<dl class="section remark"><dt>Remarks</dt><dd>this constructor will allocate memory of <code>nr*nc*sizeof(double)</code>.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>In general it is recommended to use <a class="el" href="class_matrix_factory.html#aa2e56e4b0ce04f6003b29a84b976eabc">MatrixFactory::MakeSparse</a> to create instances of sparse matrices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>number of rows </td></tr>
    <tr><td class="paramname">nc</td><td>number of columns </td></tr>
    <tr><td class="paramname">matrixType</td><td>type of matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade7027cec8e97984a31995367f0ccc48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix::Matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a new dense matrix.</p>
<dl class="section remark"><dt>Remarks</dt><dd>this constructor will allocate memory of <code>nr*nc*sizeof(double)</code> and will hard-copy the data provided into its internal state. To create a shallow copy pointing to <code>data</code> use <a class="el" href="class_matrix_factory.html#ab075ca35f3033342adcb4442de792a1d">ShallowVector</a> (only for vectors).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>number of rows </td></tr>
    <tr><td class="paramname">nc</td><td>number of columns </td></tr>
    <tr><td class="paramname">data</td><td>double values (data will be copied) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86efe4a80e926f4a237861239d641dca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix::Matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix.html#a5269c84de25f7f2ac7d05efcffde1046">MatrixType</a>&#160;</td>
          <td class="paramname"><em>matrixType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a new matrix of given dimensions, given data and given matrix type. Use this constructor only for non-sparse matrices; it is recommended to use the factory class <code><a class="el" href="class_matrix_factory.html" title="Use this class to create instances of Matrix. ">MatrixFactory</a></code> to construct instances of sparse matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>number of rows </td></tr>
    <tr><td class="paramname">nc</td><td>number of columns </td></tr>
    <tr><td class="paramname">data</td><td>double values (data will be copied) </td></tr>
    <tr><td class="paramname">matrixType</td><td>a non-sparse matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a806b603175d91477ca28ccf83ef589ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix::Matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy-constructor. This constructor will hard-copy the contents and state of the given matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b1c3627f573d78a2f08623fdfef990f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix::~Matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor.</p>
<p>Sets the row and column dimension of this matrix to <code>-1</code> and deletes the matrix data. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a78b473bbaefb449026e64127a17d517f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Matrix::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs the following operation </p>
<p class="formulaDsp">
\[ C \leftarrow \gamma C + \alpha A, \]
</p>
<p> where \(\alpha, \gamma\) are scalars, \(A\) is an instance of <a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a> provided by reference and \(C\) is a matrix to be modified.</p>
<dl class="section attention"><dt>Attention</dt><dd>Matrix C must have proper dimensions and must have allocated adequare memory, or point to allocated memory space. Shallow vectors can be used in place of either matrix <code>C</code> or <code>A</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>reference of matrix to be updated </td></tr>
    <tr><td class="paramname">alpha</td><td>scalar </td></tr>
    <tr><td class="paramname">A</td><td>given matrix \(A\) </td></tr>
    <tr><td class="paramname">gamma</td><td>scalar \(\gamma\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code. The method will return a <a class="el" href="class_for_b_e_s_utils.html#a3778b88ef7ec8a5024eec49a0d7a656d">success code</a> if the operation has succeeded and there was no need to perform any memory allocation operations. It may happen that the method succeeds, but it is necessary to allocate memory to carry out the operation. This may happen if <code>C</code> is symmetric and <code>A</code> is dense; then, matrix <code>C</code> needs to be cast as a dense matrix. In such a case the success code <a class="el" href="class_for_b_e_s_utils.html#a37381d2ec721cae5a2d424c8d962408f">STATUS_HAD_TO_REALLOC</a> is returned. In an operation is not supported, an <a class="el" href="class_for_b_e_s_utils.html#a9c1e46ac1b8075a0971d2ce770ee10d9">undefined</a> status code will be returned.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>An invalid argument exception is thrown if the matrices are not conformable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Handle the case where \(\alpha = \gamma = 0.0\).</dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>SPARSE + LOWER_TRI is too slow! </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="shallow_example_8cpp-example.html#a3">shallow_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a15c97d92d3cda9517cde2d9edbd06fac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cholmod_common * Matrix::cholmod_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the single access method to the singleton <code>cholmod_common</code> used in this project. Typically clients will not be interested in using this <code>cholmod_common</code> to perform any matrix-matrix operations or factorization, however, it can be used to check the status of computations, get the overall flop count and more.</p>
<p>This method will construct and store internally an instance of <code>cholmod_common</code> if one does not exist.</p>
<dl class="section return"><dt>Returns</dt><dd>The singleton <code>cholmod_common</code> object. </dd></dl>

</div>
</div>
<a class="anchor" id="ad018d4ba7a14f4b068e892c3477629b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Matrix::destroy_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Static method used to destroy the singleton <code>cholmod_handle</code>, if any.</p>
<dl class="section return"><dt>Returns</dt><dd>status this call returns <code>0</code> when it succeeds. See the CHOLMOD documentation for the interpretation of error codes. </dd></dl>

</div>
</div>
<a class="anchor" id="ade6530fe4f127ba13a7030b5e48e2859"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Matrix::get </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value of the current matrix at position <code>(i,j)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>row index (<code>0,...,nrows-1</code>) </td></tr>
    <tr><td class="paramname">j</td><td>column index (<code>0,...,ncols-1</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value at <code>(i,j)</code></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>in case some of the indices exceeds the maximum row or column dimension of the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is faster to use get(size_t), although it is not so convenient. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="matrix_example_8cpp-example.html#a5">matrix_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad13362789c86b598e86a817ec469fac8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Matrix::get </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the same as <code>operator[]</code>, i.e., it directly accesses the internal state of the <a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a>. This method is also equivalent to (and a shorthand for) <code>get(i)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>data index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data value</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this method will result in unexpected results or may cause the programme to crash if the index provided does not correspond to a valid position in memory. This will happen if the matrix is empty, or <code>i&gt;=<a class="el" href="class_matrix.html#a67ff18ea6f0710847b5828361a155c12">length()</a></code>, or the matrix is if type <a class="el" href="class_matrix.html#a5269c84de25f7f2ac7d05efcffde1046aaca75f6fbf0a161cc6662f2becc5ca29">Matrix::MATRIX_SPARSE</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a563d2eea637fa4cec85649bfdb83e649"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double * Matrix::getData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Getter for the matrix data. Provides direct access to the matrix data which are stored as an array of <code>double</code> (datatype <code>double*</code>). Non-sparse matrices are stored in column-major order. Lower triangular matrices are stored in packed column-major order. For symmetric matrices, only their lower triangular part is stored. For diagonal matrices we store only their diagonal elements. Note that when a matrix is transposed, the stored data are not affected - instead a boolean flag is used to indicate that the matrix is transposed.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the matrix data </dd></dl>

</div>
</div>
<a class="anchor" id="ae9b720197e7a5fe44f83d942604c0ed9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Matrix::getNcols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of columns of the current matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>number of columns as <code>int</code>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="matrix_example_8cpp-example.html#a3">matrix_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ae1329328637e15c238ff88d8bd002a90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Matrix::getNrows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of rows of the current matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>number of rows as <code>int</code>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="matrix_example_8cpp-example.html#a2">matrix_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a4354c8f295ce0d7bc1593c47a6b0e458"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html#a5269c84de25f7f2ac7d05efcffde1046">Matrix::MatrixType</a> Matrix::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the type of this matrix as <code>MatrixType</code> </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a9aad4156bde7ca184d008f84650287c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Matrix::getTypeString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the type of this matrix as a string. </p>
<dl class="section return"><dt>Returns</dt><dd>type as string</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_matrix.html#a4354c8f295ce0d7bc1593c47a6b0e458">getType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a863f25e7addbd2a92b48ed25a7223cfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Matrix::isColumnVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether this is a column vector.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is a column-vector and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a6750126006caf8bcf092eaac0e01fe08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Matrix::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether this is an empty matrix.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is an empty vector. </dd></dl>

</div>
</div>
<a class="anchor" id="aecb04d447ba10e54fdd9ceef3fbf2aac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Matrix::isRowVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether this is a row vector.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is a row-vector and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7493d04952515b36ff3f145ae2244ff6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Matrix::isSymmetric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whether the matrix is symmetric. Returns <code>true</code> if the matrix type is either MATRIX_DIAGONAL or MATRIX_SYMMETRIC.</p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a67ff18ea6f0710847b5828361a155c12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Matrix::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of data of this matrix (e.g., if this is a diagonal matrix, only its diagonal elements are stored, so the data length equals the row-dimension of the matrix).</p>
<dl class="section return"><dt>Returns</dt><dd>Data length. </dd></dl>

</div>
</div>
<a class="anchor" id="a967b3c0361c14f7539de4712226dac76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Matrix::mult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs the following operation </p>
<p class="formulaDsp">
\[ C \leftarrow \gamma C + \alpha A B, \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>reference of matrix to be updated </td></tr>
    <tr><td class="paramname">alpha</td><td>scalar which multiplies the product <code>AB</code> </td></tr>
    <tr><td class="paramname">A</td><td>matrix A </td></tr>
    <tr><td class="paramname">B</td><td>matrix B </td></tr>
    <tr><td class="paramname">gamma</td><td>scalar which multiplies C </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code. The method will return a <a class="el" href="class_for_b_e_s_utils.html#a3778b88ef7ec8a5024eec49a0d7a656d">success code</a> if the operation has succeeded and there was no need to perform any memory allocation operations.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Handle the case where \(\alpha = \gamma = 0.0\). Especially the case \(\alpha=0.0\) should be trivially handled by <code>*=</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a32b765e9e9d2c46bc2f6af1674d7080a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a> Matrix::multiplySubmatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>left_row_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>left_row_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>left_col_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>left_col_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>right_row_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>right_row_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>right_col_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>right_col_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply a submatrix of the current <code><a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a></code> object with a submatrix of a given <a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a> which contains the right-hand side of the multiplication as a submatrix.</td></tr>
    <tr><td class="paramname">left_row_start</td><td></td></tr>
    <tr><td class="paramname">left_row_end</td><td></td></tr>
    <tr><td class="paramname">left_col_start</td><td></td></tr>
    <tr><td class="paramname">left_col_end</td><td></td></tr>
    <tr><td class="paramname">right_row_start</td><td></td></tr>
    <tr><td class="paramname">right_row_end</td><td></td></tr>
    <tr><td class="paramname">right_col_start</td><td></td></tr>
    <tr><td class="paramname">right_col_end</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result as a newly created <a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a> object.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the method is applied to a matrix which is not of type <code>MATRIX_DENSE</code>. No other matrix types are supported.</td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>in case of incompatible dimensions</td></tr>
    <tr><td class="paramname">std::out_of_range</td><td>in cases indices for either of the matrices are out of range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2037979913d8ff3fda87484c275a129"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Matrix::norm_fro_sq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns the squared 2-norm of a vector or the squared Frobenius norm of a <a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a>.</p>
<p>For \(x\in\mathbb{R}^n\), the squared 2-norm is</p>
<p class="formulaDsp">
\[ \|x\|_2^2 = \sum_{i=1}^{n}x_i^2. \]
</p>
<p>The squared Frobenius norm of matrix \(A\in\mathbb{R}^{m\times n}\) is defined as</p>
<p class="formulaDsp">
\[ \|A\|_{\mathrm{fro}}^2 = \sum_{i=1}^{m}\sum_{j=1}^{n}A_{i,j}^2. \]
</p>
<p>Returns <code>0.0</code> if the matrix is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>Squared Frobenius norm. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f117287672b1edcedf1cab6edaea2b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a> Matrix::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloaded multiplication operator for <code><a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>is the right-hand side matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the multiplication of two matrices </dd></dl>

</div>
</div>
<a class="anchor" id="a248b41795fe69f2591aa95f4a5dbac79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a> Matrix::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Summation operator.</p>
<p>Matrices must have compatible dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>is the right-hand side matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a13feaec63b337a207e70bd954956d8ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a> &amp; Matrix::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>is the right-hand side matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>updated instance of <code><a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a2d6e772e2faa6080fadd50c9a2d2b130"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a> Matrix::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtraction operator.</p>
<p>Matrices must have compatible dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>is the right-hand side matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a42ce920a1bbf67675d4e7717f7afed35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a> &amp; Matrix::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>is the right-hand side matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>updated instance of <code><a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a127463de2d624abeaf5924c0f2fe798d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a> &amp; Matrix::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator. This operator copies the values of a given <a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a> object <code>right</code> into the current modifiable instance. It allocates or reallocates memory (only) if necessary.</p>
<p>Take for example the following snippet:</p>
<div class="fragment"><div class="line"><a class="code" href="class_matrix.html">Matrix</a> A(5,6);                      <span class="comment">// Allocate a 5-by-6 dense matrix</span></div>
<div class="line"><a class="code" href="class_matrix.html">Matrix</a> B = <a class="code" href="class_matrix_factory.html">MatrixFactory</a>(5,6,0,1);  <span class="comment">// Create random dense 5-by-6 matrix </span></div>
<div class="line">A = B;                              <span class="comment">// No memory will be reallocated</span></div>
</div><!-- fragment --><p>This assignment operator respects the shallowness of vectors. Take a look at the following code:</p>
<div class="fragment"><div class="line"><a class="code" href="class_matrix.html">Matrix</a> x = <a class="code" href="class_matrix_factory.html">MatrixFactory</a>(10,1,0,1);      <span class="comment">// Create random vector of dimension 10</span></div>
<div class="line"><a class="code" href="class_matrix.html">Matrix</a> shallow = ShallowVector(x, 2, 3); <span class="comment">// Create shallow sub-vector of x</span></div>
<div class="line">                                         <span class="comment">// this does not allocate memory (no data are stored)</span></div>
<div class="line"><a class="code" href="class_matrix.html">Matrix</a> y = shallow;                      <span class="comment">// y is again a shallow copy of x</span></div>
</div><!-- fragment --><p>The above example of use is what is needed most of the time. If, however, you need to get a hard copy out of any (shallow or not) matrix, use the copy constructor. Here is an example:</p>
<div class="fragment"><div class="line"><a class="code" href="class_matrix.html">Matrix</a> F = <a class="code" href="class_matrix_factory.html">MatrixFactory</a>(10,30,0,1);     </div>
<div class="line"><a class="code" href="class_matrix.html">Matrix</a> F_shallow = ShallowVector(x, 2, 3); </div>
<div class="line">               </div>
<div class="line">                          </div>
<div class="line"><a class="code" href="class_matrix.html">Matrix</a> F_shallow_copy(F_shallow);  <span class="comment">// hard copy of F_shallow</span></div>
<div class="line"><a class="code" href="class_matrix.html">Matrix</a> F_copy(F);                  <span class="comment">// hard copy of F</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>is the right-hand operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the current object. </dd></dl>

</div>
</div>
<a class="anchor" id="a6910c400bcff2148875ce8132baf70e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Matrix::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equality relational operator: returns <code>true</code> iff both sides are equal. Two matrices are equal if they are of the same type, have equal dimensions and equal values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the two objects are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a60596b6608bb8a51a2d79afcaf092849"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double &amp; Matrix::operator[] </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sub</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Direct access to the matrix data. Shorthand for <code>matrix.getData()[]</code>; it is however safer to access the matrix entries using <code>get</code> and <code>set</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sub</td><td>index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to matrix data</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>in case the provided index is out of range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60b85bd659def86b7d7c30c89e284d4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::plusop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This idempotent method updates the entries of the current matrix by applying element-wise the function <code>max(x, 0)</code>, i.e., it replaces all negative values with zeroes.</p>
<p>This operation is often denoted as \([x]_+\). </p>

</div>
</div>
<a class="anchor" id="aacb3bce122bc4f834c1732eb3abdc397"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::plusop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a> *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is the same as the idempotent method <a class="el" href="class_matrix.html#a60b85bd659def86b7d7c30c89e284d4f">Matrix::plusop()</a> but the result is stored in a given memory location specified by <code>mat</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td><a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a> to be updated with the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0c3fb9c6f0159041a9d3780d0aa7f0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Matrix::quad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the quadratic form <code>0.5 * x'*Q*x</code>.</p>
<p>Here x is a given vector as <code><a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a></code>, where Q is the current instance of <code><a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a></code>.</p>
<p>This method can only be applied on square matrices Q while x and q need to be of compatible dimensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The vector x. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Scalar 0.5*x'*Q*x as <code>double</code> as a double.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Implement quadFromSparse in case the matrix is sparse, but there are no triplets available.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the provided argument <code>x</code> is not a column-vector, or the current matrix object does not correspond to a square matrix, or <code>x</code> is of incompatible dimensions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a335a1a88224406dd9495deb69b40e540"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Matrix::quad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the quadratic form <code>0.5*x'*Q*x + q'*x</code>.</p>
<p>Here x is a given vector as <code><a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a></code>, where Q is the current instance of <code><a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a></code>.</p>
<p>This method can only be applied on square matrices Q while x and q need to be of compatible dimensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The vector x. </td></tr>
    <tr><td class="paramname">q</td><td>The parameter vector x. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of operation <code>0.5*x'*Q*x + q'*x</code> as a double.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the provided argument <code>x</code> is not a column-vector, or the current matrix object does not correspond to a square matrix, or either <code>x</code> or <code>q</code> are of incompatible dimensions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78c9e38b32c51598d4535823c6d596f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Matrix::reshape </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reshape the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nrows</td><td>new number of rows </td></tr>
    <tr><td class="paramname">ncols</td><td>new number of columns</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code: <code>0</code> if reshaping succeeded, <code>-1</code> if some of the new dimensions is 0, <code>-2</code> if reshaping is impossible. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b21e3beb1071bd78b920c5b53b3e044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::set </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates a value of the matrix at position <code>(i,j)</code>.</p>
<p>Note that when setting the value <code>A(i,j)</code> of a symmetric matrix, then both <code>A(i,j)</code> and <code>A(j,i)</code> will be set to the same value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>row index (<code>0,...,nrows-1</code>) </td></tr>
    <tr><td class="paramname">j</td><td>column index (<code>0,...,ncols-1</code>) </td></tr>
    <tr><td class="paramname">val</td><td>value to be set at <code>(i,j)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="matrix_example_8cpp-example.html#a4">matrix_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad35c63af2aa542ef4f2a3d9b5150412c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a> Matrix::submatrixCopy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a sub-matrix of the current <a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a> object into a new matrix.</p>
<p>For dense matrices, this method makes use of LAPACK's <code>dlacpy</code> and is applicable to transpose matrices as well.</p>
<p>This method is not supported yet for non-dense matrices (e.g., sparse, diagonal, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_start</td><td>row start </td></tr>
    <tr><td class="paramname">row_end</td><td>row end </td></tr>
    <tr><td class="paramname">col_start</td><td>column start </td></tr>
    <tr><td class="paramname">col_end</td><td>column end</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New matrix object with copied data</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>in case the arguments are out of range or <code>row_end &lt; row_start</code> or <code>col_end &lt; col_start</code>.</td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the method is applied to a matrix which is neither of type <code>MATRIX_DENSE</code> nor <code>MATRIX_SPARSE</code>. No other matrix types are supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a498f80096c04994899f302fbbe1abe40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::toggle_diagonal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a vector into a diagonal matrix and vice verse. This method only applies to vectors and diagonal matrices and will throw a <code>std::invalid_argument</code> exception otherwise.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the method is applied to a matrix that is neither a dense vector (type <code>MATRIX_DENSE</code>) nor a diagonal matrix (type <code>MATRIX_DIAGONAL</code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa753de1a2ed37c8eb934e06823fee179"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transpose this matrix.</p>
<p>Internally, all that this method does is to change the state of this matrix from transposed to non-transposed and vice-versa. Therefore, transposing a matrix using this method does not incur any computation cost. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="ad5c437f59e2afd60da8a880e8417856f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Operator *= with a scalar - scale a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>current modifiable matrix </td></tr>
    <tr><td class="paramname">alpha</td><td>scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ae3f78084a0dd9b26068bf0e2878406ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints out a <a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a> object to an output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">obj</td><td><a class="el" href="class_matrix.html" title="A generic matrix API. ">Matrix</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/<a class="el" href="_matrix_8h_source.html">Matrix.h</a></li>
<li>source/Matrix.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 17 2016 14:47:38 for LibForBES by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
