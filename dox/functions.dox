/* FUNCTIONS*/

/*! \page doc-functs Functions
 *
 * \brief The functions API
 * 
 * 
 * The ForBES function API allows end-users to define their own functions and at 
 * the same time provides a collection of functions that are frequently used and 
 * have applications in machine learning, control and other applications of 
 * optimization. A complete list of these functions can be found \ref Functions "here".
 *
 * Class Function has not public constructors, therefore, one cannot directly
 * create function objects. Instances of this class are created using its subclasses,
 * for example:
 *
 * \code{.cpp}
 *  double lambda = 1.0;
 *  double mu = 0.8;
 *  Function * elastic = new ElasticNet(lambda, mu);
 * \endcode
 * 
 * The Function API contains the following methods which are implemented by subclasses
 * of Function. 
 *
 * \code{.cpp}
 * int call (Matrix &x, double &f); 
 * int call (Matrix &x, double &f, Matrix &grad);
 * int callConj (const Matrix &x, double &f_star);
 * int callConj (const Matrix &x, double &f_star, Matrix &grad);
 * int callProx (const Matrix &x, double gamma, Matrix &prox);
 * int callProx (const Matrix &x, double gamma, Matrix &prox, double &f_at_prox);
 * \endcode
 * 
 * These methods provide the following functionality:
 * 1. Compute the value of the function \f$f(x)\in\mathbb{R}\f$ for a given 
 * vector \f$x\in\mathbb{R}^n\f$ or matrix \f$x\in\mathbb{R}^{n\times m}\f$
 * 2. Compute the \f$f(x)\f$ as well as its gradient \f$\nabla f(x)\f$
 * 3. Compute the value of the conjugate of the function \f$f^*(y)\f$ at a given point
 * 4. Compute the value \f$f^*(y)\f$ and the gradient \f$\nabla f^*(y)\f$
 * 5. Compute the value of the proximal operator \f$\mathrm{prox}_{\gamma f}(v)\f$ 
 * 6. Compute the proximal operator and the value of the function at
 * the proximal point, that is \f$f(\mathrm{prox}_{\gamma f}(v))\f$.
 * 
 * Not all of the above methods are always implemented. If a method is implemented
 * and the computation succeeds it returns the status code \link ForBESUtils::STATUS_OK STATUS_OK\endlink.
 *
 * If instead the method is not implemented, it will return a status code
 * \link ForBESUtils::STATUS_UNDEFINED_FUNCTION STATUS_UNDEFINED_FUNCTION\endlink. 
 *
 * If the method is implemented, but the computation fails, the method will return the code
 * \link ForBESUtils::STATUS_NUMERICAL_PROBLEMS STATUS_NUMERICAL_PROBLEMS\endlink.
 *
 * It is of course possible to know whether a particular method is implemented for a 
 * function using its \link Function::category category \endlink which returns the 
 * \link FunctionOntologicalClass ontological class\endlink of a function; an object
 * which contains meta information about the function. This is how to check whether
 * a given %Function object implements the method <code>call</code>:
 *
 * \code
 * double lambda = 1.0;
 * double mu = 0.8;
 * double fx;
 * double xdata[2] = {2.0, 3.0};
 * Matrix x(2, 1, xdata);
 * Function * elastic = new ElasticNet(lambda, mu);
 * if (elastic->category().defines_f()) {
 *   int status = elastic -> call(x, fx);
 *   if (ForBESUtils::STATUS_OK != status) {
 *      // something went wrong!
 *   }
 * }
 * \endcode
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */