/* Quadratic programs - documentation with examples */

/*! \page doc-QP QP Problems
 *  \brief %Quadratic programming with examples
 *
 *
 *
 * <div class="sec">Box-constrained QP</div>
 * Let us here see how to formulate and solve a QP using libforbes. 
 *
 * First, define the cost function as 
 * \f[
 *  f(x) = \frac{1}{2}x^{\top}Qx + q^{\top}x.
 * \f]
 *
 * Take for instance \f$Q\in\mathbb{R}^{4\times 4}\f$ and \f$q\in\mathbb{R}^{4}\f$
 * to be
 *
 * \f[
 *  Q = \begin{bmatrix}
 *  7& 2& -2& -1\\2& 3& 0& -1\\-2& 0& 3& -1\\-1& -1& -1& 1
 *  \end{bmatrix},
 * \f]
 * and
 * \f[
 *  q = \begin{bmatrix}
 *  1&2&3&4
 *  \end{bmatrix}^{\top}.
 * \f]
 *
 * We may define function \f$f\f$ as follows
 * \code{.cpp}
 * const size_t n = 4;
 * double data_Q[] = {
 *  7,  2, -2, -1,
 *  2,  3,  0, -1,
 * -2,  0,  3, -1,
 * -1, -1, -1,  1 };
 * double data_q[] = {1, 2, 3, 4};
 *
 * Matrix Q(n, n, data_Q);
 * Matrix q(n, 1, data_q);
 *
 * Function * f = new Quadratic(*Q, *q);
 * \endcode
 *
 * Let us define the constraints using an indicator function as follows
 * \f[
 *  g(z) = \delta(z\mid C), \text{ where } C=\{z: -1\leq z\leq 1\}.
 * \f]
 *
 *
 * We can now simply define function \f$g\f$ as follows
 * \code{.cpp}
 * double lb = -1;
 * double ub = +1;
 * Function * g = new IndBox(lb, ub);
 * \endcode
 *
 * Let us now define and solve the problem:
 * \f[
 *  \mathrm{minimize}\ f(x) + g(x).
 * \f]
 *
 * Here is an example:
 *
 * \code{.cpp}
 * // Define the forward-backward problem specifications
 * FBProblem prob(*f, *g);
 *
 * // Introduce a stopping criterion:
 * const double rel_tolerance = 1e-3;
 * FBStoppingRelative sc(rel_tolerance);
 *
 * // Choose an initial guess
 * Matrix x0(n, 1);
 *
 * // Construct an instance of a FB solver
 * double gamma = 0.1;
 * const int maxit = 100;
 * FBSplitting * solver = new FBSplitting(prob, x0, gamma, sc, maxit);
 *
 * // Run the solver and get the minimizer
 * int solver_status = solver->run();
 * Matrix xstar = solver->getSolution();
 * \endcode
 *
 * We chose \f$\gamma=0.1\f$ because \f$1/\|Q\|_2 \simeq 0.1163 > \gamma\f$.
 * 
 * In the end, do not forget to \c delete the various objects that were
 * constructed.
 * 
 * \code{.cpp}
 *  delete solver;
 *  delete f;
 *  delete g;
 * \endcode
 *
 * The algorithm terminates in \c 15 iterations (this is returned by
 * <code>solver->getIt()</code>) and the optimizer is
 *
 * \f[
 * x^\star = \begin{bmatrix}-0.3529&-0.7647&-1&1\end{bmatrix}^{\top}
 * \f]
 *
 * and the optimal value is \f$f(x^\star)+g(x^\star)=-7.853\f$.
 *
 * The Fast FBS method can be also used as follows
 *
 * \code
 * FBSplittingFast * solver = new FBSplittingFast(prob, x0, gamma, sc, maxit);
 * \endcode
 *
 * which converges within the required accuracy (specified by the termination
 * criterion) in \c 11 iterations.
 *
 *
 *
 *
 *
 *
 *
 * <div class="sec">Inequality constrained QP</div>
 * 
 * Let us now solve an inequality constrained problem which have the following form
 *
 * \f[
 * \mathrm{minimize}\ \frac{1}{2}x^{\top}Qx  + q^{\top} x + \delta(Hx\mid C),
 * \f]
 * 
 * where \f$Q\f$ is a symmetric positive definite matrix,  \f$H:\mathbb{R}^n\to\mathbb{R}^s\f$
 * is a linear operator and \f$C\f$ is a set which is easy to project on; here, let us take
 *
 * \f[
 *  C = \{z \in \mathbb{R}^s: -1 \leq z \leq 1\}.
 * \f]
 *
 * Using the splitting \f$f(x) = \frac{1}{2}x^{\top}Qx + q^{\top}x\f$, \f$g(z) = \delta(z\mid C)\f$
 * and \f$z=Hx\f$, we need to formulate and solve the dual optimization problem which is simply
 *
 * \f[
 *  \mathrm{minimize}\ f^*(-H^* y) + g^*(y),
 * \f]
 *
 * for the dual variable \f$y\in\mathbb{R}^s\f$.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
